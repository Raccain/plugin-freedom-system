# DSP Architecture: RadioMusic

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-5 implementation. Stage 1 Planning cannot proceed without this file. Stage 4 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Referenced by:** Stage 1 (Planning), Stage 4 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

## Core Components

### File Manager
- **JUCE Class:** `juce::AudioFormatManager`
- **Purpose:** Detect audio file formats and create readers for WAV, AIFF, MP3, FLAC, OGG files
- **Parameters Affected:** station
- **Configuration:** `registerBasicFormats()` to support all common audio formats, maintain cached list of files in selected folder, provide file access by index

### Audio Reader
- **JUCE Class:** `juce::AudioFormatReader`
- **Purpose:** Low-level streaming file reading with sample-accurate positioning
- **Parameters Affected:** start (indirectly via playback position initialization)
- **Configuration:** Created per-file by AudioFormatManager, provides `sampleRate`, `numChannels`, `lengthInSamples` properties, supports streaming for large files

### Playback Source
- **JUCE Class:** `juce::AudioFormatReaderSource`
- **Purpose:** Streaming playback wrapper implementing continuous looping and position management
- **Parameters Affected:** start
- **Configuration:** Wraps AudioFormatReader, implements `AudioSource` interface, handles buffering automatically, manages playback position and looping

### Variable Speed Resampler
- **JUCE Class:** `juce::Resampler` (Oboe MultiChannelResampler)
- **Purpose:** Real-time sample rate conversion for tape-style speed/pitch control
- **Parameters Affected:** speed_pitch
- **Configuration:** Medium quality setting (balance between CPU and quality), processes audio in blocks, converts speed parameter to rate multiplier via `pow(2, speed_pitch)`

### MIDI Trigger Detector
- **JUCE Class:** `juce::MidiBuffer`
- **Purpose:** Detect MIDI note-on events for sample-accurate re-triggering
- **Parameters Affected:** start (triggers position reset)
- **Configuration:** Process in `processBlock()`, use `isNoteOn()` to detect triggers, apply sample-accurate timing via `samplePosition`

### Volume Control
- **JUCE Class:** `juce::dsp::Gain<float>`
- **Purpose:** Final-stage output gain control
- **Parameters Affected:** volume
- **Configuration:** Convert dB to linear gain via `pow(10, volume_dB / 20.0)`, apply smoothing to prevent clicks, special case: -60dB or lower = 0.0 gain (silence)

### File System Scanner
- **JUCE Class:** `juce::File`
- **Purpose:** Folder scanning and file list management
- **Parameters Affected:** station (provides file list for indexing)
- **Configuration:** Use `findChildFiles()` to scan folder, filter for audio extensions (.wav, .aiff, .mp3, .flac, .ogg), sort alphabetically, cache results

## Processing Chain

```
MIDI In → Trigger Detection → Position Reset
                                     ↓
Folder Path → File Scanner → File List (cached)
                                     ↓
Station Parameter (0-100%) → File Index Mapping → File Manager
                                                        ↓
                                            AudioFormatReader (streaming)
                                                        ↓
Start Parameter (0-100%) → Sample Position ← Playback Source (looping)
                                                        ↓
Speed/Pitch Parameter (-1.0 to +1.0) → Rate Multiplier → Resampler
                                                               ↓
Volume Parameter (-60dB to +12dB) → Linear Gain → Volume Control
                                                         ↓
                                                      Output
```

## Parameter Mapping

| Parameter ID | DSP Component | Usage Description |
|--------------|---------------|-------------------|
| station | File Manager, File Scanner | Maps 0-100% to file index: `fileIndex = floor((station / 100.0) * totalFiles)`. Station changes queue new file (loaded on next MIDI trigger or immediately if free-running) |
| start | Playback Source, MIDI Trigger Detector | Maps 0-100% to sample position: `samplePos = floor((start / 100.0) * fileLengthInSamples)`. All MIDI triggers and transport restarts begin playback from this position |
| speed_pitch | Variable Speed Resampler | Bipolar control: -1.0 = 0.5x speed (octave down), 0.0 = 1.0x (normal), +1.0 = 2.0x (octave up). Conversion: `rate = pow(2, speed_pitch)`. Affects both speed and pitch (tape-style, no time-stretching) |
| volume | Volume Control | Output gain in dB. Conversion to linear: `gain = pow(10, volume / 20.0)`. Special case: ≤-60dB = 0.0 gain. Applied post-DSP as final stage |

## Algorithm Details

**File Queueing System:**
- Implementation approach: Station parameter changes queue next file but don't interrupt current playback. New file loads on next MIDI note-on trigger or immediately if no MIDI activity detected for 100ms.
- Key considerations: Thread-safe file loading (background thread), prevent audio glitches during file switching
- JUCE helpers available: `ThreadPoolJob` for background file loading, `CriticalSection` for thread safety

**Start Position Handling:**
- Implementation approach: Convert start percentage to sample offset, apply on playback initialization or MIDI trigger
- Key considerations: Ensure position doesn't exceed file length, handle edge cases (empty files, corrupt files)
- JUCE helpers available: `AudioFormatReader::lengthInSamples` for bounds checking

**Seamless Looping:**
- Implementation approach: Detect when playback reaches end of file, reset to start position offset. Use click-free crossfading (1-5ms) when looping.
- Key considerations: Variable speed affects loop detection timing, must recalculate loop point based on current playback rate
- JUCE helpers available: `AudioFormatReaderSource` provides position tracking, manual loop detection in `getNextAudioBlock()`

**Speed-Based Resampling:**
- Implementation approach: Map bipolar parameter (-1.0 to +1.0) to rate multiplier (0.5x to 2.0x) via `pow(2, speed_pitch)`. Apply center snap (±0.05 threshold) in UI only, DSP receives exact values.
- Key considerations: Smooth parameter changes to avoid clicks, efficient resampling algorithm (Oboe Medium quality)
- JUCE helpers available: `juce::Resampler` (Oboe integration), handles sample rate conversion efficiently

**Waveform Downsampling (for UI):**
- Implementation approach: Load full waveform on background thread, downsample to ~800 points using min/max peak detection per chunk. Send to UI via message queue.
- Key considerations: Don't block audio thread, update only on station parameter change, cache downsampled waveforms per file
- JUCE helpers available: `AudioBuffer::findMinMax()` for peak detection, `AsyncUpdater` for thread-safe UI updates

**MIDI Re-trigger Logic:**
- Implementation approach: On MIDI note-on detection, reset playback position to start offset. Apply short fade-in (1-5ms) to prevent clicks.
- Key considerations: Sample-accurate timing via `MidiMessage::samplePosition`, independent from DAW transport state
- JUCE helpers available: `MidiBuffer::Iterator`, `MidiMessage::isNoteOn()`, `smoothedValue` for fade-in

## Special Considerations

**Thread Safety:**
- File loading and waveform generation occur on background threads
- Playback state accessed from audio thread only (no locks in `processBlock()`)
- Parameter updates use atomic operations or message queues
- File list cache uses read-write lock (read from audio thread, write from UI thread)

**Performance:**
- Resampler quality: Medium (balance CPU vs audio quality)
- Waveform caching: Store downsampled waveforms in memory (max 800 points × 4 bytes = 3.2KB per file)
- Lazy loading: Only load current file's full waveform, not entire folder
- File scanning: Async on background thread, show progress indicator for large folders (>500 files)

**Denormal Protection:**
- Apply flush-to-zero on volume control output when gain < 1e-8
- Use `FloatVectorOperations::disableDenormalisedNumberSupport()` at plugin initialization

**Sample Rate Handling:**
- Resampler automatically handles sample rate conversion between file and host
- Fade-in duration (1-5ms) scales with sample rate: `fadeSamples = sampleRate * 0.003`
- Playback position tracking accounts for rate multiplier: `position += blockSize * rate`

## Research References

**Context7 JUCE Documentation:**
- Context7 Library: `/juce-framework/juce` (476 code snippets, trust score 8.3)
- AudioFormatReader API: https://docs.juce.com/master/classAudioFormatReader.html
- AudioFormatReaderSource: https://docs.juce.com/master/classAudioFormatReaderSource.html
- Build an audio player tutorial: https://docs.juce.com/master/tutorial_playing_sound_files.html
- Looping audio sample buffer: https://docs.juce.com/master/tutorial_looping_audio_sample_buffer.html

**Professional Examples:**
- Music Thing Modular Radio Music (Eurorack hardware, discontinued): Continuous playback from SD card folders (16 banks × 75 channels), files loop endlessly in background, station switching doesn't re-trigger. Direct inspiration for this plugin.
- Standard JUCE samplers: AudioFormatManager + Synthesizer class architecture, SamplerVoice and SamplerSound pattern
- Variable speed/pitch samplers (industry standard): 0.25x - 4.0x range (2 octaves), tape-style coupling (no time-stretching)

**Technical Resources:**
- JUCE Forum: Simple sampler implementation (https://doomy.org/creating-a-very-simple-sampler-audio-plugin-in-juce-5/)
- JUCE Forum: Variable speed/pitch resampling techniques
- Oboe Resampler documentation: Quality settings and CPU trade-offs

**Key Findings:**
- Hardware Radio Music uses .raw headerless files; software version supports all common formats (WAV/AIFF/MP3/FLAC/OGG) via JUCE
- Station changes in hardware don't re-trigger playback; maintained for software version with optional MIDI triggering
- Speed/pitch coupling (tape-style) is simpler and more musical than time-stretching for this use case
- Typical speed range in professional plugins: -200% to +200% or 0.25x to 4.0x; RadioMusic uses narrower range (-100% to +100%, 0.5x to 2.0x) for tighter control
- Center detent (snap) for bipolar controls is essential for precise 1.0x and 0dB settings
